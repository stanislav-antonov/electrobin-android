<!doctype html>
<html>
    <head>
        <title>Route</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <script src="http://code.jquery.com/jquery-1.12.0.min.js"></script>
        <script src="http://api-maps.yandex.ru/2.1/?lang=ru_RU" type="text/javascript"></script>
        <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no" />
        <script type="text/javascript">
            var myMap;
            var locationArrow;
            var coordSystem;

            var snapDistanceThreshold = 0.0017;
            var routeDeviationThreshold = 5;
            var routeDeviationCount = 0;
            var routePointStep = 4;

            var avoidTrafficJams;

            var routePoints;

            var currentRouteData;
            var currentRoute;

            var prevPosition;

            ymaps.ready(function () {
                var initCoords = [55.53638053374438,37.529385721565184];
                myMap = new ymaps.Map('map', {
                    center: initCoords,
                    zoom: 16,
                    geoObjectOverlayFactory: 'default#interactiveGraphics',
                    controls: ["zoomControl", "searchControl", "trafficControl"]
                });

                coordSystem = myMap.options.get('projection').getCoordSystem();

                var trafficControlButton = myMap.controls.get("trafficControl");
                trafficControlButton.events.add('select', function () {
                        avoidTrafficJams = true;
                        updateStartPoint();
                        _displayRoute(true);
                    }).add('deselect', function () {
                        avoidTrafficJams = false;
                        updateStartPoint();
                        _displayRoute(false);
                    }
                );

                Android.onMapReady();
            });


            function updateStartPoint() {
                if (prevPosition && currentRouteData && currentRouteData.hasOwnProperty("start_point")) {
                    var startPoint = currentRouteData["start_point"];
                    startPoint.latitude  = prevPosition[0];
                    startPoint.longitude = prevPosition[1];
                }
            }


            function routeToPoints(route) {
                var points = [];
                var prevSegment, currSegment;

                var paths = route.getPaths();
                for (var jj = 0; jj < paths.getLength(); jj++) {
                    var path = paths.get(jj);
                    var segments = path.getSegments();
                    for (var i = 0; i < segments.length; i++) {
                        var segment = segments[i].getCoordinates();
                        for (var j = 0; j < segment.length; j++) {
                            currSegment = segment[j];
                            if (prevSegment && prevSegment[0].toPrecision(10) === currSegment[0].toPrecision(10) && prevSegment[1].toPrecision(10) === currSegment[1].toPrecision(10)) {
                                continue;
                            }

                            points.push(currSegment);
                            prevSegment = currSegment;
                        }
                    }
                }

                var result = [];
                for (var i = 0, l = points.length - 1; l; --l, ++i) {
                    var from = points[i],
                        to = points[i + 1],
                        diff = [to[0] - from[0], to[1] - from[1]];

                    for (var j = 0, k = Math.round(coordSystem.distance(from, to)); j < k; j += routePointStep) {
                        var ratio = j / k;
                        result.push([from[0] + (diff[0] * ratio), from[1] + (diff[1] * ratio)]);
                    }
                }

                return result;
            }


            function snapToRoute(point) {
                if (!point) return null;
                if (!routePoints) {
                    console.log('no route points!');
                    return [point[0], point[1]];
                }

                var minDistance = null;
                var distance = null;
                var rpFound;

                for (var i = 0; i < routePoints.length; i++) {
                    var rp = routePoints[i];

                    var distance = Math.sqrt(Math.pow((point[0] - rp[0]), 2) + Math.pow((point[1] - rp[1]), 2));
                    if (minDistance == null) {
                        minDistance = distance;
                    }

                    if (distance < minDistance) {
                        minDistance = distance;
                        rpFound = rp;
                    }
                }

                if (minDistance < snapDistanceThreshold) {
                    return rpFound ? [rpFound[0], rpFound[1]] : null;
                } else {
                    if (routeDeviationCount > routeDeviationThreshold) {
                        routeDeviationCount = 0;
                        Android.onRouteDeviation();
                    }

                    routeDeviationCount++;

                    return [point[0], point[1]];
                }
            }


            function calcBearing(lat1, lon1, lat2, lon2) {
                var latitude1 = lat1 * Math.PI / 180;
                var latitude2 = lat2 * Math.PI / 180;
                var longDiff = (lon2 - lon1) * Math.PI / 180;
                var y = Math.sin(longDiff) * Math.cos(latitude2);
                var x = Math.cos(latitude1) * Math.sin(latitude2) - Math.sin(latitude1) * Math.cos(latitude2) * Math.cos(longDiff);

                return (Math.atan2(y, x) * (180 / Math.PI) + 360) % 360;
            }


            function updatePosition(lat, long, bearing) {
                var pointSnapped = snapToRoute([lat, long]);
                if (!pointSnapped) return;

                var b = 0;
                if (prevPosition) {
                    b = calcBearing(prevPosition[0], prevPosition[1], pointSnapped[0], pointSnapped[1]);
                }

                prevPosition = pointSnapped;

                myMap.panTo([pointSnapped]).then(
                    function () {
                        if (!locationArrow) {
                            locationArrow = new ymaps.Placemark(
                                pointSnapped, {}, {
                                    iconLayout: 'default#image',
                                    iconShadow: false,
                                    iconImageHref: 'http://185.118.64.121:8081/static/img/location_arrow.png',
                                    iconImageSize: [24, 24],
                                    iconImageOffset: [-12, -12],
                                    iconOffset: [0, 0],

                                    // preset: "islands#dotCircleIcon",
                                    // iconColor: '#ff0000'
                                }
                            );

                            myMap.geoObjects.add(locationArrow);
                        }
                        else {
                            locationArrow.geometry.setCoordinates(pointSnapped);
                        }

                        locationArrow.getOverlay().then(function (value) {
                            var $ico = $(value.getIconElement());
                            $ico.css('transform', 'rotate(' + b + 'deg)');
                        }, function (err) {
                            console.log('Ошибка: ' + err);
                        });
                    },
                    function (err) {},
                    this
                );
            }


            function displayRoute(routeJSON) {
                currentRouteData = $.parseJSON(routeJSON);
                _displayRoute();
            }


            function _displayRoute() {
                if (!currentRouteData) {
                    console.log('no route data!');
                    return;
                }

                var wayPointsData = [];
                var hasStartPoint = false;

                if (currentRouteData.hasOwnProperty("start_point")) {
                    var startPoint = currentRouteData.start_point;
                    wayPointsData.push({ type: "wayPoint", point: [ startPoint.latitude, startPoint.longitude ] });
                    hasStartPoint = true;
                }

                var wayPoints = currentRouteData.way_points;
                for (i = 0; i < wayPoints.length; i++) {
                    var wayPoint = wayPoints[i];
                    wayPointsData.push({ type: "wayPoint", point: [ wayPoint.latitude, wayPoint.longitude ] });
                }

                if (currentRoute) {
                    myMap.geoObjects.remove(currentRoute);
                }

                Android.onRouteBuildingStart();

                ymaps.route(wayPointsData, {avoidTrafficJams: avoidTrafficJams, mapStateAutoApply: true}).then(
                    function(route) {
                        var points = route.getWayPoints();

                        var startPoint = null;
                        if (hasStartPoint) {
                            startPoint = points.get(0);
                            points.remove(startPoint);
                        }

                        points.each(function (point, i) {
                            var uniqueId = wayPoints[i].unique_id;
                            point.properties.set("unique_id", uniqueId);
                            point.properties.set("iconContent", uniqueId);

                            point.options.set({
                                hasBalloon: false
                            });

                            point.events.add("click", function () {
                                Android.onRoutePointClick(point.properties.get("unique_id"));
                            });
                        });

                        if (hasStartPoint && startPoint != null) {
                            // var startPointPlacemark = new ymaps.Placemark(startPoint.geometry.getCoordinates(), {}, {
                            //    hasBalloon: false,
                            //    iconColor: "0066ff99"
                            // });
                            // points.add(startPointPlacemark, 0);
                        }

                        myMap.geoObjects.add(route);
                        routePoints = routeToPoints(route);
                        currentRoute = route;

                        Android.onRouteBuildingReady();
                    },
                    function (error) {
                        alert(error.message);
                    }
                );
            }
        </script>
        <style>
            html, body, #map {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #map {
                background-color: black;
            }

            #button {
                position: absolute;
                height: 20px;
                top: 10px; left: 10px;
            }
        </style>
    </head>
    <body>
        <div id="map"></div>
    </body>
</html>